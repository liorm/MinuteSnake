# MinuteSnake System Design

This document outlines the system design of the MinuteSnake game based on the current implementation.

## Core Components:

1.  [`GameApp`](src/app.ts):
    *   Acts as the main entry point for the application.
    *   Initializes the HTML canvas and obtains the 2D rendering context.
    *   Creates and holds an instance of the [`GameEngine`](src/game-engine.ts).
    *   Creates [`HumanActor`](src/actors.ts) and [`AIActor`](src/actors.ts) instances and adds them to the [`GameEngine`](src/game-engine.ts).
    *   Starts the game loop by calling `gameEngine.start()`.

2.  [`GameEngine`](src/game-engine.ts):
    *   The central orchestrator of the game.
    *   Manages the main game loop using `requestAnimationFrame`.
    *   Handles window events such as resizing and keyboard input.
    *   Updates the canvas dimensions based on window size changes.
    *   Coordinates the game state updates by calling `advanceTime` on the current game handler.
    *   Routes keyboard input to appropriate actors.
    *   Processes game inputs generated by actors or direct key presses.
    *   Switches between live game mode and playback mode based on user input ('p' key).
    *   Utilizes a [`GameRenderer`](src/game-renderer.ts) instance for drawing the game state.
    *   Maintains a list of [`IActor`](src/actors.ts) instances and calls their `onStateUpdate` method.
    *   Delegates game state management and logic execution to implementations of [`GameHandlerBase`](src/backend/state-handlers.ts) (`LiveHandler` or `PlaybackHandler`).

3.  [`GameRenderer`](src/game-renderer.ts):
    *   Responsible for all visual output on the HTML canvas.
    *   Initializes rendering parameters based on game stage options.
    *   Calculates tile sizes and board padding based on canvas dimensions.
    *   Provides a method to draw individual tiles on the canvas.
    *   Renders the entire game state, including the background, blocks, apple, snakes (with different colors for body and head), a playback indicator, and the game over screen.

4.  [`IActor`](src/actors.ts) (Interface) and Implementations (`HumanActor`, `AIActor`):
    *   [`IActor`](src/actors.ts): Defines the interface for entities that can interact with the game state. Actors receive state updates and can generate game inputs.
    *   [`HumanActor`](src/actors.ts): An implementation of [`IActor`](src/actors.ts) that translates keyboard input into snake direction changes for a specific snake index. It stores pending input to be returned on the next state update.
    *   [`AIActor`](src/actors.ts): An implementation of [`IActor`](src/actors.ts) that provides basic AI for a snake. It attempts to move the snake towards the apple while avoiding collisions with walls, blocks, other snakes, and its own body.

5.  [`GameLogic`](src/backend/game-logic.ts):
    *   Encapsulates the core rules and state of the game.
    *   Initialized with a game stage configuration (`IGameStage`).
    *   Manages the current game state (`IGameState`), including snake positions, lengths, directions, pending direction changes, apple position, blocks, speed, and game over status.
    *   Uses a seeded random number generator (`seedrandom`) for deterministic apple placement.
    *   Processes game inputs (`GameInput`) for direction changes and speed adjustments.
    *   Advances the game state over time (`advanceTime`), performing game steps (`_actionStep`) based on the current speed.
    *   Handles snake movement, growth when eating apples, and collision detection (with walls, blocks, other snakes, and self).
    *   Manages the placement of new apples.
    *   Can reset the game state to its initial configuration.

6.  [`GameHandlerBase`](src/backend/state-handlers.ts), `LiveHandler`, `PlaybackHandler`:
    *   These classes manage the game state and input handling based on the current game mode.
    *   [`LiveHandler`](src/backend/state-handlers.ts): Manages the active game session, processing inputs and updating the state in real-time, potentially saving inputs for replay.
    *   [`PlaybackHandler`](src/backend/state-handlers.ts): Manages the replay of a game session using saved inputs, advancing the state based on recorded events.

## Interactions:

*   [`GameApp`](src/app.ts) initializes [`GameEngine`](src/game-engine.ts) and adds [`IActor`](src/actors.ts) instances.
*   [`GameEngine`](src/game-engine.ts) runs the game loop, calling `advanceTime` on the current game handler and `render` on the [`GameRenderer`](src/game-renderer.ts) in each frame.
*   [`GameEngine`](src/game-engine.ts) receives keyboard input and routes it to the appropriate [`HumanActor`](src/actors.ts).
*   [`GameEngine`](src/game-engine.ts) calls `onStateUpdate` on all registered [`IActor`](src/actors.ts) instances, which may return `GameInput`.
*   [`GameEngine`](src/game-engine.ts) passes `GameInput` to the current game handler's `performInput` method.
*   [`LiveHandler`](src/backend/state-handlers.ts) or [`PlaybackHandler`](src/backend/state-handlers.ts) (implementations of [`GameHandlerBase`](src/backend/state-handlers.ts)) use the [`GameLogic`](src/backend/game-logic.ts) instance to update the game state based on time and inputs.
*   [`GameLogic`](src/backend/game-logic.ts) updates the `IGameState` based on game rules, collisions, and apple consumption.
*   [`GameRenderer`](src/game-renderer.ts) receives the `IGameState` from the [`GameEngine`](src/game-engine.ts) and draws the corresponding visual representation on the canvas.
*   [`HumanActor`](src/actors.ts) and [`AIActor`](src/actors.ts) receive the `IGameState` in their `onStateUpdate` method to make decisions and generate inputs.

This structure provides a clear separation of concerns, making the codebase more modular and maintainable. The use of interfaces like [`IActor`](src/actors.ts) allows for different types of players (human or AI) to be added easily. The separation of [`GameLogic`](src/backend/game-logic.ts) from [`GameEngine`](src/game-engine.ts) and [`GameRenderer`](src/game-renderer.ts) ensures that the core game rules are independent of the presentation and control layers. The state handler pattern allows for different game modes (live vs. playback) to manage the game state and inputs differently.